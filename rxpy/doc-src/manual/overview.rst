
.. _overview:

Overview
========

.. toctree::
   :maxdepth: 2

There are three main components in RXPY:

* The parser, which constructs a graph that represents the regular
  expression.

* An engine, which evaluates the regular expression (expressed as a graph)
  against an input string to find a match.

* An alphabet, which allows both the parser and engine to work with a variety
  of different input types.

In addition, there are two supporting components:

* The library graph nodes, assembled by the parser and used as opcodes by the
  engine.

* Support code that emulates the Python ``re`` library.  Currently this is
  mixed with the only engine, but it will soon be separated.

So, for example, the expression ``(?P<number>[0-9]+)|\w*`` is compiled to the
graph shown (the entry point is not indicated, but would be ``...|...`` in
this case), but the interpretation of ``[0-9]`` and ``\w`` will depend on the
alphabet used (it will not be the same for ASCII and Unicode, for example).

.. figure::  example-graph.png
   :align:   center

Parser
------

The parser is a hand-written state machine (it can also be thought of as
trampolining recursive descent!).  States are classes and the code is (in my
opinion) quite simple and easy to extend.

The source and API docs are `here <api/redirect.html#rxpy.parser.parser>`_.

Graph
-----

Each graph node represents a single opcode for the engine (although engines
are free to rewrite the graph and/or change the interpretation).

The source and API docs are `here <api/redirect.html#rxpy.parser.graph>`_.

Graph nodes also support the use of a `visitor
<api/redirect.html#rxpy.parser.visitor>`_.  Calling any node's ``visit``
method, passing in a `Visitor()
<api/redirect.html#rxpy.parser.visitor.Visitor>`_, triggers the appropriate
callback, with the correct parameters.

Engine
------

An engine must use the graph (generated by the parser) to find a match in the
input text.  RXPY currently has only one engine, so support for multiple
engines is missing, but will be added soon.

The simplest engines may work as simple interpreters, using the `Visitor()
<api/redirect.html#rxpy.parser.visitor.Visitor>`_ interface (see comments on
graphs above).  But more complex options are also possible.  For example, the
graph could be used to generate opcodes in a more traditional form for a
C-based engine, or the graph could undergo further analysis and rewriting.

Alphabet
--------

The alphabet is used in two separate ways.

#. While parsing the regular expression, it is used by the parser/graph to (i)
   generate values from numeric escapes and (ii) to construct character ranges.

#. While matching input, it is used by the engine to check membership of
   character groups (eg whitespace).
